<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>futex(2) - SerenityOS man pages</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<img src="/banner.png" style="display: block; margin-left: auto; margin-right: auto; margin-bottom: 2em;">
<header id="title-block-header">
<h1 class="title">futex(2) - SerenityOS man pages</h1>
</header>
<h2 id="name">Name</h2>
<p>futex - low-level synchronization primitive</p>
<h2 id="synopsis">Synopsis</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;serenity.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Raw syscall.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> futex<span class="op">(</span><span class="dt">uint32_t</span><span class="op">*</span> userspace_address<span class="op">,</span> <span class="dt">int</span> futex_op<span class="op">,</span> <span class="dt">uint32_t</span> value<span class="op">,</span> <span class="at">const</span> <span class="kw">struct</span> timespec<span class="op">*</span> timeout<span class="op">,</span> <span class="dt">uint32_t</span><span class="op">*</span> userspace_address2<span class="op">,</span> <span class="dt">uint32_t</span> value3<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">// More convenient wrappers.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> futex_wait<span class="op">(</span><span class="dt">uint32_t</span><span class="op">*</span> userspace_address<span class="op">,</span> <span class="dt">uint32_t</span> value<span class="op">,</span> <span class="at">const</span> <span class="kw">struct</span> timespec<span class="op">*</span> abstime<span class="op">,</span> <span class="dt">int</span> clockid<span class="op">,</span> <span class="dt">int</span> process_shared<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> futex_wake<span class="op">(</span><span class="dt">uint32_t</span><span class="op">*</span> userspace_address<span class="op">,</span> <span class="dt">uint32_t</span> count<span class="op">,</span> <span class="dt">int</span> process_shared<span class="op">);</span></span></code></pre></div>
<h2 id="description">Description</h2>
<p>The <code>futex()</code> system call provides a low-level synchronization primitive, essentially exposing the kernel's internal thread synchronization primitives to userspace.</p>
<p>While the <code>futex()</code> API is powerful and generic, it is complex and cumbersome to use, and notoriously tricky to use <em>correctly</em>. For this reason, it is not intended to be used by application code directly, but rather to serve as a building block for more specialized and easier to use synchronization primitives implemented in user space, such as mutexes and semaphores. Specifically, the <code>futex()</code> API is designed to enable userspace synchronization primitives to have a <em>fast path</em> that does not involve calling into the kernel at all in the common uncontended case, avoiding the cost of making a syscall completely.</p>
<p><em>A futex</em> is a single 32-bit integer cell located anywhere in the address space of a process (identified by its address), as well as an associated kernel-side queue of waiting threads. The kernel-side resources associated with a futex are created and destroyed implicitly when a futex is used; in other words, any 32-bit integer can be used as a futex without any specific setup, and a futex on which no threads are waiting is no different to any other integer. The kernel does not assign any meaning to the value of the futex integer; it is up to userspace to make use of the value for its own logic.</p>
<p>The <code>futex()</code> API provides a number of <em>operations</em>, the most basic ones being <em>waiting</em> and <em>waking</em>:</p>
<ul>
<li><p><code>FUTEX_WAKE</code> / <code>futex_wake()</code>: wake up to <code>count</code> threads waiting on the futex (in the raw <code>futex()</code> syscall, <code>count</code> is passed as the <code>value</code> argument). The two most common values for <code>count</code> are 1 (wake a single thread) and <code>UINT32_MAX</code> (wake all threads).</p></li>
<li><p><code>FUTEX_WAIT</code> / <code>futex_wait()</code>: wait on the futex, but only if the current value of the futex integer matches the specified <code>value</code>. The value comparison and blocking is done atomically: if another thread changes the value before the calling thread starts waiting, the calling thread will not begin waiting at all, and the <code>futex_wait()</code> call will return <code>EAGAIN</code> immediately. A waiting thread may wake up spuriously, without a matching call to <code>futex_wake()</code>.</p></li>
<li><p><code>FUTEX_WAKE_BITSET</code>: like <code>FUTEX_WAKE</code>, but only consider waiting threads that have specified a matching bitset (passed in <code>value3</code>). Two bitsets match if their <em>bitwise and</em> is non-zero. A thread that has not specified a bitset is treated as having a bitset with all bits set (<code>FUTEX_BITSET_MATCH_ANY</code>, equal to <code>0xffffffff</code>).</p></li>
<li><p><code>FUTEX_WAIT_BITSET</code>: like <code>FUTEX_WAIT</code>, but the thread will only get woken by wake operations specifying a matching bitset.</p></li>
<li><p><code>FUTEX_REQUEUE</code>: wake up to <code>value</code> threads waiting on the futex, and requeue up to <code>value2</code> (passed instead of the <code>timeout</code> argument) of the remaining waiting threads to wait on another futex specified by <code>userspace_address2</code>, without waking them up. Waking and requeueing threads is done atomically.</p>
<p>Requeueing threads without waking them up is useful to avoid "thundering herd" issues with synchronization primitives like condition variables, where multiple threads may wait for an event, but an event can only be handled by a single thread at a time.</p></li>
<li><p><code>FUTEX_CMP_REQUEUE</code>: like <code>FUTEX_REQUEUE</code>, but only if the current value of the futex integer matches the specified <code>value3</code>. The value comparison, waking and requeueing threads are all done atomically.</p></li>
<li><p><code>FUTEX_WAKE_OP</code>: modify the value of the futex specified by <code>userspace_address2</code>, wake up to <code>value</code> threads waiting on the futex, and optionally up to <code>value2</code> (passed instead of the <code>timeout</code> argument) threads waiting on the futex specified by <code>userspace_address2</code>.</p>
<p>The details of this operation are not currently documented here, see the implementation for details.</p></li>
</ul>
<p>Additionally, the <code>FUTEX_PRIVATE_FLAG</code> flag can be <em>or</em>'ed in with one of the <em>operation</em> values listed above. This flag restricts the call to only work on other threads of the same process (as opposed to any threads in the system that may have the same memory page mapped into their address space, possibly at a different address), which enables additional optimizations in the syscall implementation. The inverse of this flag is exposed as the <code>process_shared</code> argument in <code>futex_wait()</code> and <code>futex_wake()</code> wrapper functions.</p>
<h2 id="return-value">Return value</h2>
<ul>
<li><code>FUTEX_WAKE</code>, <code>FUTEX_WAKE_BITSET</code>, <code>FUTEX_WAKE_OP</code>: the number of the waiting threads that have been woken up, which may be 0 or a positive number.</li>
<li><code>FUTEX_WAIT</code>, <code>FUTEX_WAIT_BITSET</code>: 0 if blocked and got woken up by an explicit wake call or woke up spuriously, an error otherwise.</li>
<li><code>FUTEX_REQUEUE</code>, <code>FUTEX_CMP_REQUEUE</code>: the total number of threads woken up and requeued.</li>
</ul>
<h2 id="errors">Errors</h2>
<ul>
<li><code>EAGAIN</code>: for wait operations, did not begin waiting, because the futex value has already been changed.</li>
<li><code>ETIMEDOUT</code>: for wait operations with a timeout, timed out.</li>
<li><code>EFAULT</code>: the specified futex address is invalid.</li>
<li><code>ENOSYS</code>: <code>FUTEX_CLOCK_REALTIME</code> was specified, but the operation is not <code>FUTEX_WAIT</code> or <code>FUTEX_WAIT_BITSET</code>.</li>
<li><code>EINVAL</code>: The arithmetic-logical operation for <code>FUTEX_WAKE_OP</code> is invalid.</li>
</ul>
<h2 id="examples">Examples</h2>
<p>The following program demonstrates how futexes can be used to implement a simple "event" synchronization primitive. An event has a boolean state: it can be <em>set</em> or <em>unset</em>; the initial state being unset. The two operations on an event are <em>waiting</em> until it is set, and <em>setting</em> it (which wakes up any threads that were waiting for the event to get set).</p>
<p>Such a synchronization primitive could be used, for example, to notify threads that are waiting for another thread to perform some sort of complex initialization.</p>
<p>The implementation features two fast paths: both setting an event that no thread is waiting on, and trying to wait on an event that has already been set, are performed entirely in userspace without calling into the kernel. For this to work, the value of the futex integer is used to track both the state of the event (whether it has been set) and whether any threads are waiting on it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;AK/Atomic.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;serenity.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Event <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> State <span class="op">:</span> u32 <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        UnsetNoWaiters<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        UnsetWithWaiters<span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        Set<span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    AK<span class="op">::</span>Atomic<span class="op">&lt;</span>State<span class="op">&gt;</span> <span class="va">m_state</span> <span class="op">{</span> UnsetNoWaiters <span class="op">};</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    u32<span class="op">*</span> state_futex_ptr<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>u32<span class="op">*&gt;(</span><span class="kw">const_cast</span><span class="op">&lt;</span>State<span class="op">*&gt;(</span><span class="va">m_state</span><span class="op">.</span>ptr<span class="op">()));</span> <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set<span class="op">()</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        State previous_state <span class="op">=</span> <span class="va">m_state</span><span class="op">.</span>exchange<span class="op">(</span>Set<span class="op">,</span> AK<span class="op">::</span>memory_order_release<span class="op">);</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If there was anyone waiting, wake them all up.</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fast path: no one was waiting, so we&#39;re done.</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>previous_state <span class="op">==</span> UnsetWithWaiters<span class="op">)</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            futex_wake<span class="op">(</span>state_futex_ptr<span class="op">(),</span> UINT32_MAX<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> wait<span class="op">()</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If the state is UnsetNoWaiters, set it to UnsetWithWaiters.</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        State expected_state <span class="op">=</span> UnsetNoWaiters<span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> have_exchanged <span class="op">=</span> <span class="va">m_state</span><span class="op">.</span>compare_exchange_strong<span class="op">(</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            expected_state<span class="op">,</span> UnsetWithWaiters<span class="op">,</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            AK<span class="op">::</span>memory_order_acquire<span class="op">);</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>have_exchanged<span class="op">)</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>            expected_state <span class="op">=</span> UnsetWithWaiters<span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We need to check the state in a loop and not just once</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// because of the possibility of spurious wakeups.</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fast path: if the state was already Set, we&#39;re done.</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>expected_state <span class="op">!=</span> Set<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>            futex_wait<span class="op">(</span>state_futex_ptr<span class="op">(),</span> expected_state<span class="op">,</span> <span class="kw">nullptr</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>            expected_state <span class="op">=</span> <span class="va">m_state</span><span class="op">.</span>load<span class="op">(</span>AK<span class="op">::</span>memory_order_acquire<span class="op">);</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="history">History</h2>
<p>The name "futex" stands for "fast userspace mutex".</p>
<p>The <code>futex()</code> system call originally appeared in Linux. Since then, many other kernels implemented support for futex-like operations, under various names, in particular:</p>
<ul>
<li>Darwin (XNU) has private <code>ulock_wait()</code> and <code>ulock_wake()</code> API;</li>
<li>Windows (NT) apparently has <code>WaitOnAddress()</code>, <code>WakeByAddressSingle()</code> and <code>WakeByAddressAll()</code>;</li>
<li>FreeBSD and DargonFly BSD have <code>umtx</code>;</li>
<li>OpenBSD has Linux-like <code>futex()</code>;</li>
<li>GNU Hurd has <code>gsync_wait()</code>, <code>gsync_wake()</code>, and <code>gsync_requeue()</code>.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://akkadia.org/drepper/futex.pdf">Futexes Are Tricky</a> by Ulrich Drepper</li>
<li><a href="https://webkit.org/blog/6161/locking-in-webkit/">Locking in WebKit</a> by Filip Pizlo</li>
</ul>
</body>
</html>
